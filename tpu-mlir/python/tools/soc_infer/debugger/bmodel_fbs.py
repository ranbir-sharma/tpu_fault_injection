
# Automatically generated by the FlatBuffers compiler and merged by merge_pyfbs.py.
# Do not modify.

# $ flatc -o . --python xxx.fbs
# $ merge_pyfbs.py python/models out_merged.py

import flatbuffers
from flatbuffers.compat import import_numpy

np = import_numpy()


class NetParameter(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NetParameter()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsNetParameter(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def InputTensor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def InputTensorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def InputTensorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    def OutputTensor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def OutputTensorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def OutputTensorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    def CtxAddr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def CtxSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def CoeffMem(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = CoeffMem()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def IsDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def NDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def HWDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def CmdGroup(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CmdGroup()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CmdGroupLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CmdGroupIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return (o == 0)

    def NetProfile(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def StageIr(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = StageIR()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def StageIrLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def StageIrIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return (o == 0)

    def BinaryIr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def SubNet(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = SubNet()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def SubNetLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def SubNetIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return (o == 0)

    def CpuMemSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def CtxSizes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 8))))
        return 0

    def CtxSizesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint64Flags, o)
        return 0

    def CtxSizesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CtxSizesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return (o == 0)

    def NetStat(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CoreNum(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def IoAddr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def IoSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def TensorLoc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    @staticmethod
    def NetParameterStart(builder):
        builder.StartObject(20)

    @staticmethod
    def Start(builder):
        return NetParameter.NetParameterStart(builder)

    @staticmethod
    def NetParameterAddInputTensor(builder, inputTensor):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(inputTensor), 0)

    @staticmethod
    def AddInputTensor(builder, inputTensor):
        return NetParameter.NetParameterAddInputTensor(builder, inputTensor)

    @staticmethod
    def NetParameterStartInputTensorVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartInputTensorVector(builder, numElems):
        return NetParameter.NetParameterStartInputTensorVector(builder, numElems)

    @staticmethod
    def NetParameterAddOutputTensor(builder, outputTensor):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(outputTensor), 0)

    @staticmethod
    def AddOutputTensor(builder, outputTensor):
        return NetParameter.NetParameterAddOutputTensor(builder, outputTensor)

    @staticmethod
    def NetParameterStartOutputTensorVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartOutputTensorVector(builder, numElems):
        return NetParameter.NetParameterStartOutputTensorVector(builder, numElems)

    @staticmethod
    def NetParameterAddCtxAddr(builder, ctxAddr):
        builder.PrependUint64Slot(2, ctxAddr, 0)

    @staticmethod
    def AddCtxAddr(builder, ctxAddr):
        return NetParameter.NetParameterAddCtxAddr(builder, ctxAddr)

    @staticmethod
    def NetParameterAddCtxSize(builder, ctxSize):
        builder.PrependUint64Slot(3, ctxSize, 0)

    @staticmethod
    def AddCtxSize(builder, ctxSize):
        return NetParameter.NetParameterAddCtxSize(builder, ctxSize)

    @staticmethod
    def NetParameterAddCoeffMem(builder, coeffMem):
        builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(coeffMem), 0)

    @staticmethod
    def AddCoeffMem(builder, coeffMem):
        return NetParameter.NetParameterAddCoeffMem(builder, coeffMem)

    @staticmethod
    def NetParameterAddIsDynamic(builder, isDynamic):
        builder.PrependInt32Slot(5, isDynamic, 0)

    @staticmethod
    def AddIsDynamic(builder, isDynamic):
        return NetParameter.NetParameterAddIsDynamic(builder, isDynamic)

    @staticmethod
    def NetParameterAddNDynamic(builder, nDynamic):
        builder.PrependInt32Slot(6, nDynamic, 0)

    @staticmethod
    def AddNDynamic(builder, nDynamic):
        return NetParameter.NetParameterAddNDynamic(builder, nDynamic)

    @staticmethod
    def NetParameterAddHWDynamic(builder, hWDynamic):
        builder.PrependInt32Slot(7, hWDynamic, 0)

    @staticmethod
    def AddHWDynamic(builder, hWDynamic):
        return NetParameter.NetParameterAddHWDynamic(builder, hWDynamic)

    @staticmethod
    def NetParameterAddCmdGroup(builder, cmdGroup):
        builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(cmdGroup), 0)

    @staticmethod
    def AddCmdGroup(builder, cmdGroup):
        return NetParameter.NetParameterAddCmdGroup(builder, cmdGroup)

    @staticmethod
    def NetParameterStartCmdGroupVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartCmdGroupVector(builder, numElems):
        return NetParameter.NetParameterStartCmdGroupVector(builder, numElems)

    @staticmethod
    def NetParameterAddNetProfile(builder, netProfile):
        builder.PrependStructSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(netProfile), 0)

    @staticmethod
    def AddNetProfile(builder, netProfile):
        return NetParameter.NetParameterAddNetProfile(builder, netProfile)

    @staticmethod
    def NetParameterAddStageIr(builder, stageIr):
        builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(stageIr), 0)

    @staticmethod
    def AddStageIr(builder, stageIr):
        return NetParameter.NetParameterAddStageIr(builder, stageIr)

    @staticmethod
    def NetParameterStartStageIrVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartStageIrVector(builder, numElems):
        return NetParameter.NetParameterStartStageIrVector(builder, numElems)

    @staticmethod
    def NetParameterAddBinaryIr(builder, binaryIr):
        builder.PrependStructSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(binaryIr), 0)

    @staticmethod
    def AddBinaryIr(builder, binaryIr):
        return NetParameter.NetParameterAddBinaryIr(builder, binaryIr)

    @staticmethod
    def NetParameterAddSubNet(builder, subNet):
        builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(subNet), 0)

    @staticmethod
    def AddSubNet(builder, subNet):
        return NetParameter.NetParameterAddSubNet(builder, subNet)

    @staticmethod
    def NetParameterStartSubNetVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartSubNetVector(builder, numElems):
        return NetParameter.NetParameterStartSubNetVector(builder, numElems)

    @staticmethod
    def NetParameterAddCpuMemSize(builder, cpuMemSize):
        builder.PrependUint32Slot(13, cpuMemSize, 0)

    @staticmethod
    def AddCpuMemSize(builder, cpuMemSize):
        return NetParameter.NetParameterAddCpuMemSize(builder, cpuMemSize)

    @staticmethod
    def NetParameterAddCtxSizes(builder, ctxSizes):
        builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(ctxSizes), 0)

    @staticmethod
    def AddCtxSizes(builder, ctxSizes):
        return NetParameter.NetParameterAddCtxSizes(builder, ctxSizes)

    @staticmethod
    def NetParameterStartCtxSizesVector(builder, numElems):
        return builder.StartVector(8, numElems, 8)

    @staticmethod
    def StartCtxSizesVector(builder, numElems):
        return NetParameter.NetParameterStartCtxSizesVector(builder, numElems)

    @staticmethod
    def NetParameterAddNetStat(builder, netStat):
        builder.PrependStructSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(netStat), 0)

    @staticmethod
    def AddNetStat(builder, netStat):
        return NetParameter.NetParameterAddNetStat(builder, netStat)

    @staticmethod
    def NetParameterAddCoreNum(builder, coreNum):
        builder.PrependUint32Slot(16, coreNum, 0)

    @staticmethod
    def AddCoreNum(builder, coreNum):
        return NetParameter.NetParameterAddCoreNum(builder, coreNum)

    @staticmethod
    def NetParameterAddIoAddr(builder, ioAddr):
        builder.PrependUint64Slot(17, ioAddr, 0)

    @staticmethod
    def AddIoAddr(builder, ioAddr):
        return NetParameter.NetParameterAddIoAddr(builder, ioAddr)

    @staticmethod
    def NetParameterAddIoSize(builder, ioSize):
        builder.PrependUint64Slot(18, ioSize, 0)

    @staticmethod
    def AddIoSize(builder, ioSize):
        return NetParameter.NetParameterAddIoSize(builder, ioSize)

    @staticmethod
    def NetParameterAddTensorLoc(builder, tensorLoc):
        builder.PrependStructSlot(19, flatbuffers.number_types.UOffsetTFlags.py_type(tensorLoc), 0)

    @staticmethod
    def AddTensorLoc(builder, tensorLoc):
        return NetParameter.NetParameterAddTensorLoc(builder, tensorLoc)

    @staticmethod
    def NetParameterEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return NetParameter.NetParameterEnd(builder)

class Model(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Model()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsModel(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Time(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Chip(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Net(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Net()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def NetLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def NetIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return (o == 0)

    def NeuronSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def KernelModule(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = KernelModule()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def DeviceNum(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def CpuopModule(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = CpuopModule()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    @staticmethod
    def ModelStart(builder):
        builder.StartObject(9)

    @staticmethod
    def Start(builder):
        return Model.ModelStart(builder)

    @staticmethod
    def ModelAddType(builder, type):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)

    @staticmethod
    def AddType(builder, type):
        return Model.ModelAddType(builder, type)

    @staticmethod
    def ModelAddVersion(builder, version):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(version), 0)

    @staticmethod
    def AddVersion(builder, version):
        return Model.ModelAddVersion(builder, version)

    @staticmethod
    def ModelAddTime(builder, time):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(time), 0)

    @staticmethod
    def AddTime(builder, time):
        return Model.ModelAddTime(builder, time)

    @staticmethod
    def ModelAddChip(builder, chip):
        builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(chip), 0)

    @staticmethod
    def AddChip(builder, chip):
        return Model.ModelAddChip(builder, chip)

    @staticmethod
    def ModelAddNet(builder, net):
        builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(net), 0)

    @staticmethod
    def AddNet(builder, net):
        return Model.ModelAddNet(builder, net)

    @staticmethod
    def ModelStartNetVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartNetVector(builder, numElems):
        return Model.ModelStartNetVector(builder, numElems)

    @staticmethod
    def ModelAddNeuronSize(builder, neuronSize):
        builder.PrependUint64Slot(5, neuronSize, 0)

    @staticmethod
    def AddNeuronSize(builder, neuronSize):
        return Model.ModelAddNeuronSize(builder, neuronSize)

    @staticmethod
    def ModelAddKernelModule(builder, kernelModule):
        builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(kernelModule), 0)

    @staticmethod
    def AddKernelModule(builder, kernelModule):
        return Model.ModelAddKernelModule(builder, kernelModule)

    @staticmethod
    def ModelAddDeviceNum(builder, deviceNum):
        builder.PrependUint32Slot(7, deviceNum, 0)

    @staticmethod
    def AddDeviceNum(builder, deviceNum):
        return Model.ModelAddDeviceNum(builder, deviceNum)

    @staticmethod
    def ModelAddCpuopModule(builder, cpuopModule):
        builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(cpuopModule), 0)

    @staticmethod
    def AddCpuopModule(builder, cpuopModule):
        return Model.ModelAddCpuopModule(builder, cpuopModule)

    @staticmethod
    def ModelEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Model.ModelEnd(builder)

class SubNet(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SubNet()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsSubNet(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def SubnetMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def CmdGroup(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CmdGroup()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CmdGroupLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CmdGroupIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    def CpuParam(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CpuParam()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CpuParamLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CpuParamIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return (o == 0)

    def InputTensor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def InputTensorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def InputTensorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return (o == 0)

    def OutputTensor(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Tensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def OutputTensorLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def OutputTensorIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return (o == 0)

    def IsDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def IrOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def IrLen(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def NDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def HWDynamic(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return (- 1)

    def NextSubnetIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 4))))
        return 0

    def NextSubnetIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    def NextSubnetIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def NextSubnetIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return (o == 0)

    def MergeParam(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = MergeParam()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def SwitchParam(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = SwitchParam()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CoreCommands(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CoreCommands()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CoreCommandsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CoreCommandsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return (o == 0)

    @staticmethod
    def SubNetStart(builder):
        builder.StartObject(15)

    @staticmethod
    def Start(builder):
        return SubNet.SubNetStart(builder)

    @staticmethod
    def SubNetAddSubnetMode(builder, subnetMode):
        builder.PrependInt32Slot(0, subnetMode, 0)

    @staticmethod
    def AddSubnetMode(builder, subnetMode):
        return SubNet.SubNetAddSubnetMode(builder, subnetMode)

    @staticmethod
    def SubNetAddCmdGroup(builder, cmdGroup):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(cmdGroup), 0)

    @staticmethod
    def AddCmdGroup(builder, cmdGroup):
        return SubNet.SubNetAddCmdGroup(builder, cmdGroup)

    @staticmethod
    def SubNetStartCmdGroupVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartCmdGroupVector(builder, numElems):
        return SubNet.SubNetStartCmdGroupVector(builder, numElems)

    @staticmethod
    def SubNetAddCpuParam(builder, cpuParam):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(cpuParam), 0)

    @staticmethod
    def AddCpuParam(builder, cpuParam):
        return SubNet.SubNetAddCpuParam(builder, cpuParam)

    @staticmethod
    def SubNetStartCpuParamVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartCpuParamVector(builder, numElems):
        return SubNet.SubNetStartCpuParamVector(builder, numElems)

    @staticmethod
    def SubNetAddInputTensor(builder, inputTensor):
        builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(inputTensor), 0)

    @staticmethod
    def AddInputTensor(builder, inputTensor):
        return SubNet.SubNetAddInputTensor(builder, inputTensor)

    @staticmethod
    def SubNetStartInputTensorVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartInputTensorVector(builder, numElems):
        return SubNet.SubNetStartInputTensorVector(builder, numElems)

    @staticmethod
    def SubNetAddOutputTensor(builder, outputTensor):
        builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(outputTensor), 0)

    @staticmethod
    def AddOutputTensor(builder, outputTensor):
        return SubNet.SubNetAddOutputTensor(builder, outputTensor)

    @staticmethod
    def SubNetStartOutputTensorVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartOutputTensorVector(builder, numElems):
        return SubNet.SubNetStartOutputTensorVector(builder, numElems)

    @staticmethod
    def SubNetAddIsDynamic(builder, isDynamic):
        builder.PrependInt32Slot(5, isDynamic, 0)

    @staticmethod
    def AddIsDynamic(builder, isDynamic):
        return SubNet.SubNetAddIsDynamic(builder, isDynamic)

    @staticmethod
    def SubNetAddIrOffset(builder, irOffset):
        builder.PrependUint32Slot(6, irOffset, 0)

    @staticmethod
    def AddIrOffset(builder, irOffset):
        return SubNet.SubNetAddIrOffset(builder, irOffset)

    @staticmethod
    def SubNetAddIrLen(builder, irLen):
        builder.PrependUint32Slot(7, irLen, 0)

    @staticmethod
    def AddIrLen(builder, irLen):
        return SubNet.SubNetAddIrLen(builder, irLen)

    @staticmethod
    def SubNetAddNDynamic(builder, nDynamic):
        builder.PrependInt32Slot(8, nDynamic, 0)

    @staticmethod
    def AddNDynamic(builder, nDynamic):
        return SubNet.SubNetAddNDynamic(builder, nDynamic)

    @staticmethod
    def SubNetAddHWDynamic(builder, hWDynamic):
        builder.PrependInt32Slot(9, hWDynamic, 0)

    @staticmethod
    def AddHWDynamic(builder, hWDynamic):
        return SubNet.SubNetAddHWDynamic(builder, hWDynamic)

    @staticmethod
    def SubNetAddId(builder, id):
        builder.PrependInt32Slot(10, id, (- 1))

    @staticmethod
    def AddId(builder, id):
        return SubNet.SubNetAddId(builder, id)

    @staticmethod
    def SubNetAddNextSubnetIds(builder, nextSubnetIds):
        builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(nextSubnetIds), 0)

    @staticmethod
    def AddNextSubnetIds(builder, nextSubnetIds):
        return SubNet.SubNetAddNextSubnetIds(builder, nextSubnetIds)

    @staticmethod
    def SubNetStartNextSubnetIdsVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartNextSubnetIdsVector(builder, numElems):
        return SubNet.SubNetStartNextSubnetIdsVector(builder, numElems)

    @staticmethod
    def SubNetAddMergeParam(builder, mergeParam):
        builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(mergeParam), 0)

    @staticmethod
    def AddMergeParam(builder, mergeParam):
        return SubNet.SubNetAddMergeParam(builder, mergeParam)

    @staticmethod
    def SubNetAddSwitchParam(builder, switchParam):
        builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(switchParam), 0)

    @staticmethod
    def AddSwitchParam(builder, switchParam):
        return SubNet.SubNetAddSwitchParam(builder, switchParam)

    @staticmethod
    def SubNetAddCoreCommands(builder, coreCommands):
        builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(coreCommands), 0)

    @staticmethod
    def AddCoreCommands(builder, coreCommands):
        return SubNet.SubNetAddCoreCommands(builder, coreCommands)

    @staticmethod
    def SubNetStartCoreCommandsVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartCoreCommandsVector(builder, numElems):
        return SubNet.SubNetStartCoreCommandsVector(builder, numElems)

    @staticmethod
    def SubNetEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return SubNet.SubNetEnd(builder)

class Cascade(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Cascade()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCascade(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def DeviceId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def Step(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def MainName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    @staticmethod
    def CascadeStart(builder):
        builder.StartObject(3)

    @staticmethod
    def Start(builder):
        return Cascade.CascadeStart(builder)

    @staticmethod
    def CascadeAddDeviceId(builder, deviceId):
        builder.PrependUint32Slot(0, deviceId, 0)

    @staticmethod
    def AddDeviceId(builder, deviceId):
        return Cascade.CascadeAddDeviceId(builder, deviceId)

    @staticmethod
    def CascadeAddStep(builder, step):
        builder.PrependUint32Slot(1, step, 0)

    @staticmethod
    def AddStep(builder, step):
        return Cascade.CascadeAddStep(builder, step)

    @staticmethod
    def CascadeAddMainName(builder, mainName):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(mainName), 0)

    @staticmethod
    def AddMainName(builder, mainName):
        return Cascade.CascadeAddMainName(builder, mainName)

    @staticmethod
    def CascadeEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Cascade.CascadeEnd(builder)

class CpuConst(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CpuConst()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCpuConst(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def ConstData(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CheckCode(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 1))))
        return 0

    def CheckCodeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    def CheckCodeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CheckCodeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return (o == 0)

    @staticmethod
    def CpuConstStart(builder):
        builder.StartObject(3)

    @staticmethod
    def Start(builder):
        return CpuConst.CpuConstStart(builder)

    @staticmethod
    def CpuConstAddName(builder, name):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

    @staticmethod
    def AddName(builder, name):
        return CpuConst.CpuConstAddName(builder, name)

    @staticmethod
    def CpuConstAddConstData(builder, constData):
        builder.PrependStructSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(constData), 0)

    @staticmethod
    def AddConstData(builder, constData):
        return CpuConst.CpuConstAddConstData(builder, constData)

    @staticmethod
    def CpuConstAddCheckCode(builder, checkCode):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(checkCode), 0)

    @staticmethod
    def AddCheckCode(builder, checkCode):
        return CpuConst.CpuConstAddCheckCode(builder, checkCode)

    @staticmethod
    def CpuConstStartCheckCodeVector(builder, numElems):
        return builder.StartVector(1, numElems, 1)

    @staticmethod
    def StartCheckCodeVector(builder, numElems):
        return CpuConst.CpuConstStartCheckCodeVector(builder, numElems)

    @staticmethod
    def CpuConstEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CpuConst.CpuConstEnd(builder)

class NetDynamic(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NetDynamic()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsNetDynamic(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    @staticmethod
    def NetDynamicStart(builder):
        builder.StartObject(0)

    @staticmethod
    def Start(builder):
        return NetDynamic.NetDynamicStart(builder)

    @staticmethod
    def NetDynamicEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return NetDynamic.NetDynamicEnd(builder)

class SwitchParam(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SwitchParam()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsSwitchParam(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def OutputFrom(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 4))))
        return 0

    def OutputFromAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    def OutputFromLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def OutputFromIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    def OutputBranch(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 4))))
        return 0

    def OutputBranchAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    def OutputBranchLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def OutputBranchIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    @staticmethod
    def SwitchParamStart(builder):
        builder.StartObject(2)

    @staticmethod
    def Start(builder):
        return SwitchParam.SwitchParamStart(builder)

    @staticmethod
    def SwitchParamAddOutputFrom(builder, outputFrom):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(outputFrom), 0)

    @staticmethod
    def AddOutputFrom(builder, outputFrom):
        return SwitchParam.SwitchParamAddOutputFrom(builder, outputFrom)

    @staticmethod
    def SwitchParamStartOutputFromVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartOutputFromVector(builder, numElems):
        return SwitchParam.SwitchParamStartOutputFromVector(builder, numElems)

    @staticmethod
    def SwitchParamAddOutputBranch(builder, outputBranch):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(outputBranch), 0)

    @staticmethod
    def AddOutputBranch(builder, outputBranch):
        return SwitchParam.SwitchParamAddOutputBranch(builder, outputBranch)

    @staticmethod
    def SwitchParamStartOutputBranchVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartOutputBranchVector(builder, numElems):
        return SwitchParam.SwitchParamStartOutputBranchVector(builder, numElems)

    @staticmethod
    def SwitchParamEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return SwitchParam.SwitchParamEnd(builder)

class KernelModule(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KernelModule()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsKernelModule(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def FileName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Binary(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    @staticmethod
    def KernelModuleStart(builder):
        builder.StartObject(2)

    @staticmethod
    def Start(builder):
        return KernelModule.KernelModuleStart(builder)

    @staticmethod
    def KernelModuleAddFileName(builder, fileName):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(fileName), 0)

    @staticmethod
    def AddFileName(builder, fileName):
        return KernelModule.KernelModuleAddFileName(builder, fileName)

    @staticmethod
    def KernelModuleAddBinary(builder, binary):
        builder.PrependStructSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(binary), 0)

    @staticmethod
    def AddBinary(builder, binary):
        return KernelModule.KernelModuleAddBinary(builder, binary)

    @staticmethod
    def KernelModuleEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return KernelModule.KernelModuleEnd(builder)

class Shape(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Shape()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsShape(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Dim(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 8))))
        return 0

    def DimAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint64Flags, o)
        return 0

    def DimLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def DimIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    @staticmethod
    def ShapeStart(builder):
        builder.StartObject(1)

    @staticmethod
    def Start(builder):
        return Shape.ShapeStart(builder)

    @staticmethod
    def ShapeAddDim(builder, dim):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(dim), 0)

    @staticmethod
    def AddDim(builder, dim):
        return Shape.ShapeAddDim(builder, dim)

    @staticmethod
    def ShapeStartDimVector(builder, numElems):
        return builder.StartVector(8, numElems, 8)

    @staticmethod
    def StartDimVector(builder, numElems):
        return Shape.ShapeStartDimVector(builder, numElems)

    @staticmethod
    def ShapeEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Shape.ShapeEnd(builder)

class CpuParam(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CpuParam()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCpuParam(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def OpType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def BinaryParam(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CpuConst(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CpuConst()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CpuConstLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CpuConstIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return (o == 0)

    def IsCustom(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def CpuParamStart(builder):
        builder.StartObject(4)

    @staticmethod
    def Start(builder):
        return CpuParam.CpuParamStart(builder)

    @staticmethod
    def CpuParamAddOpType(builder, opType):
        builder.PrependInt32Slot(0, opType, 0)

    @staticmethod
    def AddOpType(builder, opType):
        return CpuParam.CpuParamAddOpType(builder, opType)

    @staticmethod
    def CpuParamAddBinaryParam(builder, binaryParam):
        builder.PrependStructSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(binaryParam), 0)

    @staticmethod
    def AddBinaryParam(builder, binaryParam):
        return CpuParam.CpuParamAddBinaryParam(builder, binaryParam)

    @staticmethod
    def CpuParamAddCpuConst(builder, cpuConst):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(cpuConst), 0)

    @staticmethod
    def AddCpuConst(builder, cpuConst):
        return CpuParam.CpuParamAddCpuConst(builder, cpuConst)

    @staticmethod
    def CpuParamStartCpuConstVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartCpuConstVector(builder, numElems):
        return CpuParam.CpuParamStartCpuConstVector(builder, numElems)

    @staticmethod
    def CpuParamAddIsCustom(builder, isCustom):
        builder.PrependInt32Slot(3, isCustom, 0)

    @staticmethod
    def AddIsCustom(builder, isCustom):
        return CpuParam.CpuParamAddIsCustom(builder, isCustom)

    @staticmethod
    def CpuParamEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CpuParam.CpuParamEnd(builder)

class StageIR(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = StageIR()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsStageIR(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def IrInfoLen(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def HeightHigh(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def HeightLow(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def WidthHigh(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def WidthLow(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def StageIRStart(builder):
        builder.StartObject(5)

    @staticmethod
    def Start(builder):
        return StageIR.StageIRStart(builder)

    @staticmethod
    def StageIRAddIrInfoLen(builder, irInfoLen):
        builder.PrependUint32Slot(0, irInfoLen, 0)

    @staticmethod
    def AddIrInfoLen(builder, irInfoLen):
        return StageIR.StageIRAddIrInfoLen(builder, irInfoLen)

    @staticmethod
    def StageIRAddHeightHigh(builder, heightHigh):
        builder.PrependInt32Slot(1, heightHigh, 0)

    @staticmethod
    def AddHeightHigh(builder, heightHigh):
        return StageIR.StageIRAddHeightHigh(builder, heightHigh)

    @staticmethod
    def StageIRAddHeightLow(builder, heightLow):
        builder.PrependInt32Slot(2, heightLow, 0)

    @staticmethod
    def AddHeightLow(builder, heightLow):
        return StageIR.StageIRAddHeightLow(builder, heightLow)

    @staticmethod
    def StageIRAddWidthHigh(builder, widthHigh):
        builder.PrependInt32Slot(3, widthHigh, 0)

    @staticmethod
    def AddWidthHigh(builder, widthHigh):
        return StageIR.StageIRAddWidthHigh(builder, widthHigh)

    @staticmethod
    def StageIRAddWidthLow(builder, widthLow):
        builder.PrependInt32Slot(4, widthLow, 0)

    @staticmethod
    def AddWidthLow(builder, widthLow):
        return StageIR.StageIRAddWidthLow(builder, widthLow)

    @staticmethod
    def StageIREnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return StageIR.StageIREnd(builder)

class Net(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Net()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsNet(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def NetStatic(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = NetStatic()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def NetStaticLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def NetStaticIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    def NetDynamic(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = NetDynamic()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def NetDynamicLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def NetDynamicIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return (o == 0)

    def Parameter(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = NetParameter()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def ParameterLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def ParameterIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return (o == 0)

    def Cascade(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            x = self._tab.Indirect((o + self._tab.Pos))
            obj = Cascade()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def AddrMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def NetStart(builder):
        builder.StartObject(6)

    @staticmethod
    def Start(builder):
        return Net.NetStart(builder)

    @staticmethod
    def NetAddName(builder, name):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

    @staticmethod
    def AddName(builder, name):
        return Net.NetAddName(builder, name)

    @staticmethod
    def NetAddNetStatic(builder, netStatic):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(netStatic), 0)

    @staticmethod
    def AddNetStatic(builder, netStatic):
        return Net.NetAddNetStatic(builder, netStatic)

    @staticmethod
    def NetStartNetStaticVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartNetStaticVector(builder, numElems):
        return Net.NetStartNetStaticVector(builder, numElems)

    @staticmethod
    def NetAddNetDynamic(builder, netDynamic):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(netDynamic), 0)

    @staticmethod
    def AddNetDynamic(builder, netDynamic):
        return Net.NetAddNetDynamic(builder, netDynamic)

    @staticmethod
    def NetStartNetDynamicVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartNetDynamicVector(builder, numElems):
        return Net.NetStartNetDynamicVector(builder, numElems)

    @staticmethod
    def NetAddParameter(builder, parameter):
        builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(parameter), 0)

    @staticmethod
    def AddParameter(builder, parameter):
        return Net.NetAddParameter(builder, parameter)

    @staticmethod
    def NetStartParameterVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartParameterVector(builder, numElems):
        return Net.NetStartParameterVector(builder, numElems)

    @staticmethod
    def NetAddCascade(builder, cascade):
        builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(cascade), 0)

    @staticmethod
    def AddCascade(builder, cascade):
        return Net.NetAddCascade(builder, cascade)

    @staticmethod
    def NetAddAddrMode(builder, addrMode):
        builder.PrependInt32Slot(5, addrMode, 0)

    @staticmethod
    def AddAddrMode(builder, addrMode):
        return Net.NetAddAddrMode(builder, addrMode)

    @staticmethod
    def NetEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Net.NetEnd(builder)

class NetStatic(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NetStatic()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsNetStatic(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    @staticmethod
    def NetStaticStart(builder):
        builder.StartObject(0)

    @staticmethod
    def Start(builder):
        return NetStatic.NetStaticStart(builder)

    @staticmethod
    def NetStaticEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return NetStatic.NetStaticEnd(builder)

class Location(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Location()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsLocation(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Offset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def Size(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def LocationStart(builder):
        builder.StartObject(3)

    @staticmethod
    def Start(builder):
        return Location.LocationStart(builder)

    @staticmethod
    def LocationAddName(builder, name):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

    @staticmethod
    def AddName(builder, name):
        return Location.LocationAddName(builder, name)

    @staticmethod
    def LocationAddOffset(builder, offset):
        builder.PrependUint64Slot(1, offset, 0)

    @staticmethod
    def AddOffset(builder, offset):
        return Location.LocationAddOffset(builder, offset)

    @staticmethod
    def LocationAddSize(builder, size):
        builder.PrependUint64Slot(2, size, 0)

    @staticmethod
    def AddSize(builder, size):
        return Location.LocationAddSize(builder, size)

    @staticmethod
    def LocationEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Location.LocationEnd(builder)

class CmdGroup(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CmdGroup()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCmdGroup(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def BdcNum(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def GdmaNum(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def BinaryBdc(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def BinaryGdma(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def BdcCmdByte(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def GdmaCmdByte(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def CmdGroupStart(builder):
        builder.StartObject(6)

    @staticmethod
    def Start(builder):
        return CmdGroup.CmdGroupStart(builder)

    @staticmethod
    def CmdGroupAddBdcNum(builder, bdcNum):
        builder.PrependUint32Slot(0, bdcNum, 0)

    @staticmethod
    def AddBdcNum(builder, bdcNum):
        return CmdGroup.CmdGroupAddBdcNum(builder, bdcNum)

    @staticmethod
    def CmdGroupAddGdmaNum(builder, gdmaNum):
        builder.PrependUint32Slot(1, gdmaNum, 0)

    @staticmethod
    def AddGdmaNum(builder, gdmaNum):
        return CmdGroup.CmdGroupAddGdmaNum(builder, gdmaNum)

    @staticmethod
    def CmdGroupAddBinaryBdc(builder, binaryBdc):
        builder.PrependStructSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(binaryBdc), 0)

    @staticmethod
    def AddBinaryBdc(builder, binaryBdc):
        return CmdGroup.CmdGroupAddBinaryBdc(builder, binaryBdc)

    @staticmethod
    def CmdGroupAddBinaryGdma(builder, binaryGdma):
        builder.PrependStructSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(binaryGdma), 0)

    @staticmethod
    def AddBinaryGdma(builder, binaryGdma):
        return CmdGroup.CmdGroupAddBinaryGdma(builder, binaryGdma)

    @staticmethod
    def CmdGroupAddBdcCmdByte(builder, bdcCmdByte):
        builder.PrependUint32Slot(4, bdcCmdByte, 0)

    @staticmethod
    def AddBdcCmdByte(builder, bdcCmdByte):
        return CmdGroup.CmdGroupAddBdcCmdByte(builder, bdcCmdByte)

    @staticmethod
    def CmdGroupAddGdmaCmdByte(builder, gdmaCmdByte):
        builder.PrependUint32Slot(5, gdmaCmdByte, 0)

    @staticmethod
    def AddGdmaCmdByte(builder, gdmaCmdByte):
        return CmdGroup.CmdGroupAddGdmaCmdByte(builder, gdmaCmdByte)

    @staticmethod
    def CmdGroupEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CmdGroup.CmdGroupEnd(builder)

class Tensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Tensor()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsTensor(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def GmemStmode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def DeviceAddr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def Size(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Shape()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return (o == 0)

    def MemType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def Scale(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Float32Flags, (o + self._tab.Pos))
        return 1.0

    def CpuAddr(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def PadH(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, (o + self._tab.Pos))
        return 0

    def ZeroPoint(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def Hidden(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    def Index(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (o + self._tab.Pos))
        return 0

    @staticmethod
    def TensorStart(builder):
        builder.StartObject(13)

    @staticmethod
    def Start(builder):
        return Tensor.TensorStart(builder)

    @staticmethod
    def TensorAddName(builder, name):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

    @staticmethod
    def AddName(builder, name):
        return Tensor.TensorAddName(builder, name)

    @staticmethod
    def TensorAddDataType(builder, dataType):
        builder.PrependUint32Slot(1, dataType, 0)

    @staticmethod
    def AddDataType(builder, dataType):
        return Tensor.TensorAddDataType(builder, dataType)

    @staticmethod
    def TensorAddGmemStmode(builder, gmemStmode):
        builder.PrependInt32Slot(2, gmemStmode, 0)

    @staticmethod
    def AddGmemStmode(builder, gmemStmode):
        return Tensor.TensorAddGmemStmode(builder, gmemStmode)

    @staticmethod
    def TensorAddDeviceAddr(builder, deviceAddr):
        builder.PrependUint64Slot(3, deviceAddr, 0)

    @staticmethod
    def AddDeviceAddr(builder, deviceAddr):
        return Tensor.TensorAddDeviceAddr(builder, deviceAddr)

    @staticmethod
    def TensorAddSize(builder, size):
        builder.PrependUint64Slot(4, size, 0)

    @staticmethod
    def AddSize(builder, size):
        return Tensor.TensorAddSize(builder, size)

    @staticmethod
    def TensorAddShape(builder, shape):
        builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)

    @staticmethod
    def AddShape(builder, shape):
        return Tensor.TensorAddShape(builder, shape)

    @staticmethod
    def TensorStartShapeVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartShapeVector(builder, numElems):
        return Tensor.TensorStartShapeVector(builder, numElems)

    @staticmethod
    def TensorAddMemType(builder, memType):
        builder.PrependUint32Slot(6, memType, 0)

    @staticmethod
    def AddMemType(builder, memType):
        return Tensor.TensorAddMemType(builder, memType)

    @staticmethod
    def TensorAddScale(builder, scale):
        builder.PrependFloat32Slot(7, scale, 1.0)

    @staticmethod
    def AddScale(builder, scale):
        return Tensor.TensorAddScale(builder, scale)

    @staticmethod
    def TensorAddCpuAddr(builder, cpuAddr):
        builder.PrependUint32Slot(8, cpuAddr, 0)

    @staticmethod
    def AddCpuAddr(builder, cpuAddr):
        return Tensor.TensorAddCpuAddr(builder, cpuAddr)

    @staticmethod
    def TensorAddPadH(builder, padH):
        builder.PrependUint32Slot(9, padH, 0)

    @staticmethod
    def AddPadH(builder, padH):
        return Tensor.TensorAddPadH(builder, padH)

    @staticmethod
    def TensorAddZeroPoint(builder, zeroPoint):
        builder.PrependInt32Slot(10, zeroPoint, 0)

    @staticmethod
    def AddZeroPoint(builder, zeroPoint):
        return Tensor.TensorAddZeroPoint(builder, zeroPoint)

    @staticmethod
    def TensorAddHidden(builder, hidden):
        builder.PrependInt32Slot(11, hidden, 0)

    @staticmethod
    def AddHidden(builder, hidden):
        return Tensor.TensorAddHidden(builder, hidden)

    @staticmethod
    def TensorAddIndex(builder, index):
        builder.PrependInt32Slot(12, index, 0)

    @staticmethod
    def AddIndex(builder, index):
        return Tensor.TensorAddIndex(builder, index)

    @staticmethod
    def TensorEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return Tensor.TensorEnd(builder)

class Binary(object):
    __slots__ = ['_tab']

    @classmethod
    def SizeOf(cls):
        return 16

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Start(self):
        return self._tab.Get(flatbuffers.number_types.Uint64Flags, (self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(0)))

    def Size(self):
        return self._tab.Get(flatbuffers.number_types.Uint64Flags, (self._tab.Pos + flatbuffers.number_types.UOffsetTFlags.py_type(8)))

    @staticmethod
    def CreateBinary(builder, start, size):
        builder.Prep(8, 16)
        builder.PrependUint64(size)
        builder.PrependUint64(start)
        return builder.Offset()

class OutputFrom(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OutputFrom()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsOutputFrom(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Indice(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 4))))
        return 0

    def IndiceAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    def IndiceLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def IndiceIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    @staticmethod
    def OutputFromStart(builder):
        builder.StartObject(1)

    @staticmethod
    def Start(builder):
        return OutputFrom.OutputFromStart(builder)

    @staticmethod
    def OutputFromAddIndice(builder, indice):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(indice), 0)

    @staticmethod
    def AddIndice(builder, indice):
        return OutputFrom.OutputFromAddIndice(builder, indice)

    @staticmethod
    def OutputFromStartIndiceVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartIndiceVector(builder, numElems):
        return OutputFrom.OutputFromStartIndiceVector(builder, numElems)

    @staticmethod
    def OutputFromEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return OutputFrom.OutputFromEnd(builder)

class CoeffMem(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CoeffMem()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCoeffMem(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def Address(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, (o + self._tab.Pos))
        return 0

    def CheckCode(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, (a + flatbuffers.number_types.UOffsetTFlags.py_type((j * 1))))
        return 0

    def CheckCodeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    def CheckCodeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CheckCodeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    def BinaryCoeff(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def Location(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = Location()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def LocationLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def LocationIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return (o == 0)

    @staticmethod
    def CoeffMemStart(builder):
        builder.StartObject(4)

    @staticmethod
    def Start(builder):
        return CoeffMem.CoeffMemStart(builder)

    @staticmethod
    def CoeffMemAddAddress(builder, address):
        builder.PrependUint64Slot(0, address, 0)

    @staticmethod
    def AddAddress(builder, address):
        return CoeffMem.CoeffMemAddAddress(builder, address)

    @staticmethod
    def CoeffMemAddCheckCode(builder, checkCode):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(checkCode), 0)

    @staticmethod
    def AddCheckCode(builder, checkCode):
        return CoeffMem.CoeffMemAddCheckCode(builder, checkCode)

    @staticmethod
    def CoeffMemStartCheckCodeVector(builder, numElems):
        return builder.StartVector(1, numElems, 1)

    @staticmethod
    def StartCheckCodeVector(builder, numElems):
        return CoeffMem.CoeffMemStartCheckCodeVector(builder, numElems)

    @staticmethod
    def CoeffMemAddBinaryCoeff(builder, binaryCoeff):
        builder.PrependStructSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(binaryCoeff), 0)

    @staticmethod
    def AddBinaryCoeff(builder, binaryCoeff):
        return CoeffMem.CoeffMemAddBinaryCoeff(builder, binaryCoeff)

    @staticmethod
    def CoeffMemAddLocation(builder, location):
        builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(location), 0)

    @staticmethod
    def AddLocation(builder, location):
        return CoeffMem.CoeffMemAddLocation(builder, location)

    @staticmethod
    def CoeffMemStartLocationVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartLocationVector(builder, numElems):
        return CoeffMem.CoeffMemStartLocationVector(builder, numElems)

    @staticmethod
    def CoeffMemEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CoeffMem.CoeffMemEnd(builder)

class MergeParam(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MergeParam()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsMergeParam(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def OutputFrom(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = OutputFrom()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def OutputFromLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def OutputFromIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    @staticmethod
    def MergeParamStart(builder):
        builder.StartObject(1)

    @staticmethod
    def Start(builder):
        return MergeParam.MergeParamStart(builder)

    @staticmethod
    def MergeParamAddOutputFrom(builder, outputFrom):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(outputFrom), 0)

    @staticmethod
    def AddOutputFrom(builder, outputFrom):
        return MergeParam.MergeParamAddOutputFrom(builder, outputFrom)

    @staticmethod
    def MergeParamStartOutputFromVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartOutputFromVector(builder, numElems):
        return MergeParam.MergeParamStartOutputFromVector(builder, numElems)

    @staticmethod
    def MergeParamEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return MergeParam.MergeParamEnd(builder)

class CpuopModule(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CpuopModule()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCpuopModule(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def FileName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.String((o + self._tab.Pos))
        return None

    def Binary(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = (o + self._tab.Pos)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    @staticmethod
    def CpuopModuleStart(builder):
        builder.StartObject(2)

    @staticmethod
    def Start(builder):
        return CpuopModule.CpuopModuleStart(builder)

    @staticmethod
    def CpuopModuleAddFileName(builder, fileName):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(fileName), 0)

    @staticmethod
    def AddFileName(builder, fileName):
        return CpuopModule.CpuopModuleAddFileName(builder, fileName)

    @staticmethod
    def CpuopModuleAddBinary(builder, binary):
        builder.PrependStructSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(binary), 0)

    @staticmethod
    def AddBinary(builder, binary):
        return CpuopModule.CpuopModuleAddBinary(builder, binary)

    @staticmethod
    def CpuopModuleEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CpuopModule.CpuopModuleEnd(builder)

class CoreCommands(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CoreCommands()
        x.Init(buf, (n + offset))
        return x

    @classmethod
    def GetRootAsCoreCommands(cls, buf, offset=0):
        'This method is deprecated. Please switch to GetRootAs.'
        return cls.GetRootAs(buf, offset)

    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    def GdmaTiuCommands(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4)
            x = self._tab.Indirect(x)
            obj = CmdGroup()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def GdmaTiuCommandsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def GdmaTiuCommandsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return (o == 0)

    def SdmaCommands(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def SdmaCommandsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def SdmaCommandsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return (o == 0)

    def HauCommands(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def HauCommandsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def HauCommandsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return (o == 0)

    def CdmaCommands(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            x = self._tab.Vector(o)
            x += (flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16)
            obj = Binary()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    def CdmaCommandsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if (o != 0):
            return self._tab.VectorLen(o)
        return 0

    def CdmaCommandsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return (o == 0)

    @staticmethod
    def CoreCommandsStart(builder):
        builder.StartObject(4)

    @staticmethod
    def Start(builder):
        return CoreCommands.CoreCommandsStart(builder)

    @staticmethod
    def CoreCommandsAddGdmaTiuCommands(builder, gdmaTiuCommands):
        builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(gdmaTiuCommands), 0)

    @staticmethod
    def AddGdmaTiuCommands(builder, gdmaTiuCommands):
        return CoreCommands.CoreCommandsAddGdmaTiuCommands(builder, gdmaTiuCommands)

    @staticmethod
    def CoreCommandsStartGdmaTiuCommandsVector(builder, numElems):
        return builder.StartVector(4, numElems, 4)

    @staticmethod
    def StartGdmaTiuCommandsVector(builder, numElems):
        return CoreCommands.CoreCommandsStartGdmaTiuCommandsVector(builder, numElems)

    @staticmethod
    def CoreCommandsAddSdmaCommands(builder, sdmaCommands):
        builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(sdmaCommands), 0)

    @staticmethod
    def AddSdmaCommands(builder, sdmaCommands):
        return CoreCommands.CoreCommandsAddSdmaCommands(builder, sdmaCommands)

    @staticmethod
    def CoreCommandsStartSdmaCommandsVector(builder, numElems):
        return builder.StartVector(16, numElems, 8)

    @staticmethod
    def StartSdmaCommandsVector(builder, numElems):
        return CoreCommands.CoreCommandsStartSdmaCommandsVector(builder, numElems)

    @staticmethod
    def CoreCommandsAddHauCommands(builder, hauCommands):
        builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(hauCommands), 0)

    @staticmethod
    def AddHauCommands(builder, hauCommands):
        return CoreCommands.CoreCommandsAddHauCommands(builder, hauCommands)

    @staticmethod
    def CoreCommandsStartHauCommandsVector(builder, numElems):
        return builder.StartVector(16, numElems, 8)

    @staticmethod
    def StartHauCommandsVector(builder, numElems):
        return CoreCommands.CoreCommandsStartHauCommandsVector(builder, numElems)

    @staticmethod
    def CoreCommandsAddCdmaCommands(builder, cdmaCommands):
        builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(cdmaCommands), 0)

    @staticmethod
    def AddCdmaCommands(builder, cdmaCommands):
        return CoreCommands.CoreCommandsAddCdmaCommands(builder, cdmaCommands)

    @staticmethod
    def CoreCommandsStartCdmaCommandsVector(builder, numElems):
        return builder.StartVector(16, numElems, 8)

    @staticmethod
    def StartCdmaCommandsVector(builder, numElems):
        return CoreCommands.CoreCommandsStartCdmaCommandsVector(builder, numElems)

    @staticmethod
    def CoreCommandsEnd(builder):
        return builder.EndObject()

    @staticmethod
    def End(builder):
        return CoreCommands.CoreCommandsEnd(builder)
